# 数据结构

## 轻重链剖分  

```cpp
void dfs1(int x, int pre) {
	siz[x] = 1; mson[x] = 0;
	dth[x] = dth[pre] + 1;
	fa[x] = pre;
	for(auto y : son[x]) if(y != pre) {
		dfs1(y, x);
		siz[x] += siz[y];
		if(!mson[x] || siz[y] > siz[mson[x]]) 
			mson[x] = y;
	}
}
void dfs2(int x, int pre, int ntp) {
	id[x] = ++idcnt;
	ltp[x] = ntp;
	if(mson[x]) dfs2(mson[x], x, ntp);
	for(auto y : son[x]) {
		if(y == mson[x] || y == pre) continue;
		dfs2(y, x, y);
	}
}
void link_modify(int x, int y, int z) {
	z %= mod;
	while(ltp[x] != ltp[y]) {
		dth[ltp[x]] < dth[ltp[y]] && (x ^= y ^= x ^= y);
		modify(1, n, id[ltp[x]], id[x], 1, z);
		x = fa[ltp[x]];
		
	}
	dth[x] < dth[y] && (x ^= y ^= x ^= y);
	modify(1, n, id[y], id[x], 1, z);
}
int link_query(int x, int y) {
	int ans = 0;
	while(ltp[x] != ltp[y]) {
		dth[ltp[x]] < dth[ltp[y]] && (x ^= y ^= x ^= y);
		ans = (1ll * ans + query(1, n, id[ltp[x]], id[x], 1)) % mod;
		x = fa[ltp[x]];
	}
	dth[x] < dth[y] && (x ^= y ^= x ^= y);
	ans = (1ll * ans + query(1, n, id[y], id[x], 1)) % mod;
	return ans;
}
```

